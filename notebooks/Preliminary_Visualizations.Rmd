---
title: "Preliminary Visualizations"
author: "Jaryd Hunter"
Date: "`r Sys.Date()`"
output: html_document
df_print: paged
---
This is the notbook form of the script Preliminary_Visualizations.R, I think in this form I can put these knitted html files on google drive and ideally this will give a better sense of what I have done than just a hodge podge of figures and text files.
```{r global_options, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, fig.path = '../figures/',
                      dev = 'png')
library(tidyverse);library(cowplot);library(NMF)
library(gridExtra);library(ggforce)
source('../scripts/import_data.R')
```


First import all the data received from Miriam and remove all constant variables, since they contain no information. Note: every column is numeric except for the Plate variable.

```{r import_data}
varGtrZero <- function(x){(!is.numeric(x) || var(x, na.rm = T) > 0)}
dat <- import_data('../data/Datasets/') %>% select_if(varGtrZero)
head(dat)
```

Look at the correlation between all of the variables.

```{r correlation}
cormat <- cor(dat %>% select_if(is.numeric), use = "na.or.complete")
aheatmap(cormat, color = "-RdBu:100", breaks = 0)
```

A few variables look very correlated, and below I extracted those that are equal
to -1, or 1.
```{r specific_correlation}
cormat %>% 
  as_tibble(rownames = 'Var1') %>%
  gather(key = 'Var2', value = 'cor', -Var1) %>%
  filter(Var1 != Var2 & abs(cor) == 1)
```

It's not obviously clear to me what these columns are, but keeping both does not increase the information in the dataset, so one of each pair should be dropped moving forward.

Moving on, check for batch effects across the plates.
```{r plate_batch_effect, include=FALSE, eval=FALSE}
TBP <- dat %>% select(-Row, -Column, -S, -M, -starts_with('Focus'), -DNA_Area, -Ab_Int_Nuc)
measures <- syms(names(TBP)[!grepl(pattern = "Plate", x = names(TBP))])
plts <- lapply(X = measures, FUN = function(y, dat, x){
                                           x <- enquo(x); y <- enquo(y)
                                           smldat <- dat %>% select(!!x, !!y)
                                           ggplot(smldat, aes(x = !!x, y = !!y)) +
                                             geom_boxplot()}, TBP, Plate)
marrangeGrob(plts, nrow=2, ncol=2)
```

It was hard to tell what is happening with the bulk of the data for many of the generated plots since there are a few extreme outliers. So when plotting these I scaled the viewing window window to be 5% larger on both sides of the whiskers of the boxes.

```{r plate_batch_zoom}
Boxplt_adjust_view <- function(y, dat, x){
  stopifnot(require(tidyverse))
  x <- enquo(x); y <- enquo(y)
  smldat <- dat %>% select(!!x, !!y) #x is always column 1 now.
  p0 <- ggplot(smldat, aes(x = !!x, y = !!y)) +
          geom_boxplot()
  ylim1 <- boxplot.stats(smldat[[2]])$stats[c(1,5)]  %>%
    {. + c(-0.05, 0.05)*diff(.)}
  ggplot(smldat, aes(x = !!x, y = !!y)) +
    geom_boxplot() +
    coord_cartesian(ylim = ylim1)
}

TBP <- dat %>% select(-Row, -Column, -S, -M, -starts_with('Focus'), -DNA_Area, -Ab_Int_Nuc)
measures <- syms(names(TBP)[!grepl(pattern = "Plate", x = names(TBP))])
plts <- lapply(X = measures, FUN = Boxplt_adjust_view, TBP, Plate)

marrangeGrob(plts, nrow=2, ncol=2)
```

Looks pretty good to me, I don't think there is any difference in the plates that needs to be corrected. Most likely it's been corrected for this already. If anything perhaps a mean correction.

Look at the distributions separated by mutant and non-mutant.
```{r univariate_dist, include=FALSE, eval=FALSE}
TBP <- dat %>% mutate(mutant = Row > 3)
measures <- syms(names(TBP)[!grepl(pattern = '(Plate)|(mutant)', x = names(TBP))])
plts <- lapply(X = measures, FUN = function(x, dat, y){
                                            x <- enquo(x);y <- enquo(y)
                                            smldat <- dat %>% select(!!x, !!y)
                                            ggplot() +
                                              stat_density(geom = 'line', 
                                                           data = smldat %>% filter(mutant == T), 
                                                           aes(x = !!x, colour = TRUE)) +
                                              stat_density(geom = 'line', 
                                                           data = smldat %>% filter(mutant == F), 
                                                           aes(x = !!x, colour = FALSE)) +
                                              labs(colour = 'mutant')}, TBP, mutant) 

marrangeGrob(plts, nrow=2, ncol=2)
```

Again I rescaled the viewing window where the x axis is zoomed to contain from the 0.01 percentile to 0.99 percentile plus 5% of the total distance on either side. For future it may be wise to remove these extreme outliers, since they have an effect on the shape of the tails for each distribution.

```{r uni_dist_zoomed}
density_adj_view <- function(x, dat, grp, percentiles){
  stopifnot(require(tidyverse))
  x <- enquo(x); grp <- enquo(grp)
  smldat <- dat %>% select(!!x, !!grp)
  xlim <- smldat %>% select(!!x) %>%
    summarise_all(list(~quantile(., probs = 0.01),
                       ~quantile(., probs = 0.99)), na.rm = T) %>%
    unlist(.[1,]) %>% {. + c(-0.05, 0.05)*diff(.)}
  ggplot() +
    stat_density(geom = 'line', data = smldat %>% filter(mutant == T), aes(x = !!x, colour = TRUE)) +
    stat_density(geom = 'line', data = smldat %>% filter(mutant == F), aes(x = !!x, colour = FALSE)) + 
    coord_cartesian(xlim = xlim) + 
    labs(colour = 'mutant')
}

TBP <- dat %>% mutate(mutant = Row > 3)
measures <- syms(names(TBP)[!grepl(pattern = '(Plate)|(mutant)', x = names(TBP))])
plts <- lapply(X = measures, FUN = density_adj_view, TBP, mutant, c(0.01, 0.99))

marrangeGrob(plts, nrow=2, ncol=2)

```



